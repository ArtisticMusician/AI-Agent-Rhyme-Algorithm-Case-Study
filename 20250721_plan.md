# Plan for Perfect Rhyme Algorithm Development

## Date: 2025-07-21

### 1. Initial Setup
- Create `plan.md` (done) and `log.md` files.
- Read `data/20250720_RhymeDictionary.txt` to understand its structure.
- Read `data/TestPerfect.txt` to understand the ground truth for perfect rhymes.
- Convert `data/20250720_RhymeDictionary.txt` into a more usable TypeScript format (e.g., `src/data/dictionary.ts` exporting a map/object). This will involve parsing the text file.

### 2. Algorithm Ideation (at least 3 distinct approaches)

#### Algorithm 1: Simple Suffix Match (Baseline)
- **Concept:** Identify rhymes by comparing the last few characters or syllables of words. This will be a basic string-based comparison.
- **Details:** Need to define what constitutes a "suffix" for rhyming. Perhaps a fixed number of characters or a simple heuristic based on vowels/consonants.
- **Expected Performance:** Low F1-Score, primarily for establishing a baseline.

#### Algorithm 2: Phonetic Rhyme (Using CMU Pronouncing Dictionary principles)
- **Concept:** Analyze the phonetic representation of words from the dictionary. Perfect rhymes typically involve matching vowel sounds and all subsequent consonant sounds, with different preceding consonant sounds.
- **Details:**
    - Parse the phonetic data from the converted dictionary.
    - Identify the primary stressed vowel and all sounds following it.
    - Compare these phonetic sequences.
- **Expected Performance:** Significantly better than Algorithm 1, as it leverages phonetic information.

#### Algorithm 3: Stress-based Phonetic Rhyme (Refinement of Algorithm 2)
- **Concept:** Extend Algorithm 2 by explicitly incorporating stress patterns if available in the dictionary. Perfect rhymes often require matching stress.
- **Details:**
    - If the phonetic dictionary includes stress markers, use them to refine the matching criteria.
    - Ensure that the primary stress falls on the same syllable in both words for a perfect rhyme.
- **Expected Performance:** Potentially higher F1-Score than Algorithm 2, especially for more nuanced cases.

### 3. Testing Framework
- Develop a TypeScript utility (`src/rhyme-tester.ts`) to:
    - Read `data/TestPerfect.txt`.
    - Take an algorithm's output (list of rhyme pairs).
    - Compare the algorithm's output against the ground truth.
    - Calculate True Positives (TP), False Positives (FP), False Negatives (FN).
    - Calculate Precision = TP / (TP + FP).
    - Calculate Recall = TP / (TP + FN).
    - Calculate F1-Score = 2 * (Precision * Recall) / (Precision + Recall).
    - Log these metrics.
- Integrate this utility with Jest for automated testing.

### 4. Implementation Steps (Iterative for each algorithm)
- **For each Algorithm (1, 2, 3):**
    1.  Implement the core logic in a dedicated TypeScript file (e.g., `src/simple-suffix.ts`, `src/phonetic-rhyme.ts`).
    2.  Create a corresponding test file (e.g., `src/simple-suffix.test.ts`, `src/phonetic-rhyme.test.ts`) using Jest and the `rhyme-tester.ts` utility.
    3.  Run the tests.
    4.  Log the F1-Score, TP, FP, and FN in `log.md`.
    5.  Analyze False Positives and False Negatives to understand algorithm weaknesses.
    6.  Refine the current algorithm or proceed to the next based on analysis and F1-Score.

### 5. Refinement and Documentation
- Identify the best-performing algorithm(s) based on F1-Scores.
- Further refine the chosen algorithm(s) to maximize F1-Score (aim for 1.0).
- Ensure all code adheres to modularity, clarity (comments for "why"), and testability standards.
- Finalize `log.md` with a comprehensive record of all experiments, results, and decisions.
- Provide clear documentation for the final algorithm.
